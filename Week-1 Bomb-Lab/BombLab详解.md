#BombLab实验分析
- **实验整体分析**

实验是基于Linux x86-64的，其中bomb文件是一个64位的可执行程序，bomb.c文件是一个C语言程序，其中包含了main函数以及其他许多函数。该实验共包含**六个关卡(Phase_1-Phase_6)**，每一关需要我们正确的输入密码，才能不引爆炸弹，并进行下一关。

这就需要需要我们通过对可执行文件**bomb**进行逆向分析，在其中寻找出正确答案，从而过关。此实验需要汇编基础，并配合gdb完成。（不会用gdb的请看我的实验指南文件，里面有gdb命令文档）

- **Phase_1分析**

我们使用`gdb bomb`命令进入程序，进入后在phase_1的函数入口处打上断点 命令为：`b phase_1`，进入后输入`r`是程序运行会出现如下语句：`Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!`即表示运行成功。

此时我们随意输入任意值，便会触发断点。会出现一大堆东西，看着很复杂，但是我们不用慌，此时我们输入`disassemble phase_1`这个命令，便可以对phase_1进行反汇编，会在屏幕上显示出phase_1的汇编代码：


```
0x0000000000400ee0 <+0>:     sub    rsp,0x8
   0x0000000000400ee4 <+4>:     mov    esi,0x402400
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   eax,eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    rsp,0x8
   0x0000000000400efb <+27>:    ret
```


这里我们可以发现，由于是64位，

- 第一行的栈顶指针**从esp变为了rsp**

- 第二行对esi（既rsi的低32位）赋了一个地址：**0x402400**，由于是64位的程序，前六个参数在寄存器中，所以**rsi的低32位（既esi的值）**作为参数传给了后面的`strings_not_equal`的函数

- 在第三行call了一个函数，该函数名为`strings_not_equal`，可以使用命令`disassemble strings_not_equal`查看该函数汇编，可以发现该函数是用来比较**用户输入的字符串和esi中的值是否相等**，若相等则过关，不相等就会引爆炸弹

分析到这里，第一关的答案就很明显了，第一关我们需要的密码就是**esi中的那个地址中（0x402400）存放的值**，那我们使用命令`x/s 0x402400`即可查看其中的值

Phase_1答案：Border relations with Canada have never been better.

- **Phase_2分析**

我们此时继续输入`disassemble phase_2`命令来对Phase_2进行反汇编，汇编代码为：

```
0x0000000000400efc <+0>:     push   rbp
   0x0000000000400efd <+1>:     push   rbx
   0x0000000000400efe <+2>:     sub    rsp,0x28
   0x0000000000400f02 <+6>:     mov    rsi,rsp
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmp    DWORD PTR [rsp],0x1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    eax,DWORD PTR [rbx-0x4]
   0x0000000000400f1a <+30>:    add    eax,eax
   0x0000000000400f1c <+32>:    cmp    DWORD PTR [rbx],eax
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    rbx,0x4
   0x0000000000400f29 <+45>:    cmp    rbx,rbp
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    rbx,[rsp+0x4]
   0x0000000000400f35 <+57>:    lea    rbp,[rsp+0x18]
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    rsp,0x28
   0x0000000000400f40 <+68>:    pop    rbx
   0x0000000000400f41 <+69>:    pop    rbp
   0x0000000000400f42 <+70>:    ret
```

阅读代码后可以发现

- `0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>`这个地方进行了函数调用，读入了六个数字。

- 对`Phase_2 <+14>`的分析
```
0x0000000000400f0a <+14>:    cmp    DWORD PTR [rsp],0x1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
```
这三句话的作用为**将rsp指向的值与0x1**进行比较，如果不相等就会引爆炸弹，如果相等，则会**跳到`Phase_2 <+52>`的位置**,而rsp的值为我们的输入

也就是说为了不引爆炸弹，我们的第一个数字必须为1

- 对`Phase_2 <+52>`的分析

可以看见该位置及其往后的两段代码为：

```
0x0000000000400f30 <+52>:    lea    rbx,[rsp+0x4]
   0x0000000000400f35 <+57>:    lea    rbp,[rsp+0x18]
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
```

+52的位置**将rsp+0x4处的值**给了rbx，+57的位置**将rsp+0x18处的值给了rbp**，这两句执行完以后跳转到了`Phase_2<+27>`的位置。**注意**：我们输入的第一个数字在rsp中，而整数占4个字节，也就是说rsp+0x4的位置存放的正是我们输入的第二个数字，请记住这一点，在后面的分析中非常重要

- 对`Phase_2<+27>`的分析

我们关注一下这四句话：


```
 0x0000000000400f17 <+27>:    mov    eax,DWORD PTR [rbx-0x4]
   0x0000000000400f1a <+30>:    add    eax,eax
   0x0000000000400f1c <+32>:    cmp    DWORD PTR [rbx],eax
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
```

+27的位置**将rbx-0x4处的值**给了eax，然后+30的位置，将eax里的值乘了2，并与rbx里的值进行比较，若相等则跳到`Phase_2 <+41>`的位置，不相等就会引爆炸弹。

而再看我们前面对于`Phase_2 <+52>`的分析，可以发现，**rbx里的值是rsp+0x4处的值**，也就是说rbx里的值为我们输入的第二个值，那么rbx-0x4存的就是我们输入的第一个值。

那么这里的四句话的作用就很明显了，既将我们现在输入的值与前一个输入的值乘以2来进行比较，若不相等，则炸弹被引爆，若相等则跳到`Phase_2 <+41>`的位置

- 对`Phase_2<+41>`的分析

在+41的位置我们可以看见这里使rbx=rbx+0x4，既现在rbx里的值，是我们输入的第三个值，然后进行了一个比较以后，若没通过则回到`Phase_2<+27>`的位置，那么可以看出，这是一个循环，这个循环的作用是确保**后一个输入的值为前一个输入乘以2**。

那么再回到我们最开始对于`Phase_2 <+14>`的分析，可以得知：输入的第一个值必须为1，且需要输入六个数字，每一个数字的值要等于前一个数字乘以2，那么Phase_2的密码就很明显了。

Phase_2的答案为：1 2 4 8 16 32

- **Phase_3分析**

同样，输入命令：`disassemble phase_3`即可得到phase_3的汇编代码：

```
0x0000000000400f43 <+0>:     sub    rsp,0x18
   0x0000000000400f47 <+4>:     lea    rcx,[rsp+0xc]
   0x0000000000400f4c <+9>:     lea    rdx,[rsp+0x8]
   0x0000000000400f51 <+14>:    mov    esi,0x4025cf
   0x0000000000400f56 <+19>:    mov    eax,0x0
   0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    eax,0x1
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmp    DWORD PTR [rsp+0x8],0x7
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    eax,DWORD PTR [rsp+0x8]
   0x0000000000400f75 <+50>:    jmp    QWORD PTR [rax*8+0x402470]
   0x0000000000400f7c <+57>:    mov    eax,0xcf
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    eax,0x2c3
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    eax,0x100
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    eax,0x185
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    eax,0xce
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    eax,0x2aa
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    eax,0x147
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    eax,0x0
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    eax,0x137
   0x0000000000400fbe <+123>:   cmp    eax,DWORD PTR [rsp+0xc]
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    rsp,0x18
   0x0000000000400fcd <+138>:   ret
```

- 阅读代码可以发现程序使用户在
`0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>`这里进行了输入

那我们接着往下看会发现程序对rsp+0x8这个地址里的值就行了检验，若大于0x7则会跳到`Phase_3 <+106>`的位置，这个地方会call出引爆炸弹的函数，也就是说，rsp+0x8的位置的值必须小于7

- 对于`Phase <+46>`的分析

当我们顺利通过了检验，便会来到`Phase <+46>`的位置，这里将rsp+0x8的值给了eax，然后将跳转到`[rax*8+0x402470]`这个位置

其实这里仔细想一想你会发现rsp+0x8的值是你输入的值，并且这个值被赋给了eax（也就是rax的低32位），也就是说你跳转到的位置是根据你的输入的值乘以8来确定的，如果对于高级语言熟悉的兄弟，应该能猜到，其实从`0x0000000000400f71 <+46>:    mov    eax,DWORD PTR [rsp+0x8]`这里开始，就是高级语言中的switch语句

也就是说，我们如果输入0，则表达式`[rax*8+0x402470]`会变为：`[0*8+0x402470]`，也就是说直接跳转到0x402470这个地址里值的位置。

`此处为什么并不是直接到0x402470呢？`

因为在汇编语言中，中括号[]表示的是取括号里地址的值！

那么我们使用gdb的命令`x/16x 0x402470`来查看0x402470地址里的值，可以发现这个存的地址即为`Phase_3 <+57>`处的地址，可以发现这个位置将0xcf这个值给了eax，然后跳转到程序结束的位置。

那么到这里，我们需要的密码也就出来了，而且由于是switch分支，此题的答案并不唯一，跟输入有关。

Phase_3的答案为：0 207（207为0xcf的十进制），其他答案请自己动手尝试！

- **Phase_4分析**

输入命令`disassemble phase_4`即可得到Phase_4的汇编代码：
```
0x000000000040100c <+0>:     sub    rsp,0x18
   0x0000000000401010 <+4>:     lea    rcx,[rsp+0xc]
   0x0000000000401015 <+9>:     lea    rdx,[rsp+0x8]
   0x000000000040101a <+14>:    mov    esi,0x4025cf
   0x000000000040101f <+19>:    mov    eax,0x0
   0x0000000000401024 <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    eax,0x2
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmp    DWORD PTR [rsp+0x8],0xe
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    edx,0xe
   0x000000000040103f <+51>:    mov    esi,0x0
   0x0000000000401044 <+56>:    mov    edi,DWORD PTR [rsp+0x8]
   0x0000000000401048 <+60>:    call   0x400fce <func4>
   0x000000000040104d <+65>:    test   eax,eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmp    DWORD PTR [rsp+0xc],0x0
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    call   0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    rsp,0x18
   0x0000000000401061 <+85>:    ret
```

可以看见
```0x000000000040101a <+14>:    mov    esi,0x4025cf
   0x000000000040101f <+19>:    mov    eax,0x0
   0x0000000000401024 <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
 0x0000000000401029 <+29>:    cmp    eax,0x2
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
```

这三句话给esi、eax分别赋值为：0x4025cf、0x0，并接受了用户输入，接下来将eax的值与0x2作比较，不相等直接就引爆炸弹

- 对`Phase_4 <+34>`的分析

当我们通过检验后，便会来到`Phase_4 <+34>`的位置，这里我们需要对以下几句话分析：
```
0x000000000040102e <+34>:    cmp    DWORD PTR [rsp+0x8],0xe
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    edx,0xe
   0x000000000040103f <+51>:    mov    esi,0x0
   0x0000000000401044 <+56>:    mov    edi,DWORD PTR [rsp+0x8]
   0x0000000000401048 <+60>:    call   0x400fce <func4>
```

+34的位置，将我们输入的值与0xe比较大小，如果大于了0xe，则会引爆炸弹，那么我们得到了第一个信息：**我们输入的值要小于等于0xe**

当通过检验以后，我们会来到+46的位置，这里将edx，esi，edi分别赋值为**0xe，0x0，以及rsp+0x8这个位置的值**，并作为参数进入了func4这个函数，这里请记住他们的值，会在后面的分析中用到

**那接下来我们就来分析分析func4这个函数的功能**

使用命令`disassemble func4`来得到func4的汇编代码：
```
0x0000000000400fce <+0>:     sub    rsp,0x8
   0x0000000000400fd2 <+4>:     mov    eax,edx
   0x0000000000400fd4 <+6>:     sub    eax,esi
   0x0000000000400fd6 <+8>:     mov    ecx,eax
   0x0000000000400fd8 <+10>:    shr    ecx,0x1f
   0x0000000000400fdb <+13>:    add    eax,ecx
   0x0000000000400fdd <+15>:    sar    eax,1
   0x0000000000400fdf <+17>:    lea    ecx,[rax+rsi*1]
   0x0000000000400fe2 <+20>:    cmp    ecx,edi
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    edx,[rcx-0x1]
   0x0000000000400fe9 <+27>:    call   0x400fce <func4>
   0x0000000000400fee <+32>:    add    eax,eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    eax,0x0
   0x0000000000400ff7 <+41>:    cmp    ecx,edi
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    esi,[rcx+0x1]
   0x0000000000400ffe <+48>:    call   0x400fce <func4>
   0x0000000000401003 <+53>:    lea    eax,[rax+rax*1+0x1]
   0x0000000000401007 <+57>:    add    rsp,0x8
   0x000000000040100b <+61>:    ret
```

这个函数我们主要是需要理解这几句话：

```
0x0000000000400fdf <+17>:    lea    ecx,[rax+rsi*1]
   0x0000000000400fe2 <+20>:    cmp    ecx,edi
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    edx,[rcx-0x1]
   0x0000000000400fe9 <+27>:    call   0x400fce <func4>
   0x0000000000400fee <+32>:    add    eax,eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    eax,0x0
   0x0000000000400ff7 <+41>:    cmp    ecx,edi
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    esi,[rcx+0x1]
   0x0000000000400ffe <+48>:    call   0x400fce <func4>
```

- 对`func4 <+17>`的分析

这句话其实乍一看不知道在干什么，其实分析一下这几句话之前的代码会发现，rax此时其实等于（edx-esi）/2，那么这句话其实就相当于ecx=（edx+esi）/2，而这**恰好就是edx+esi的均值**，后面为了方便，我会直接将ecx的值称为均值。这里如果不知道为什么rax等于（edx-esi）/2的，可以去复习一下汇编基础。

当赋值完成后，ecx与edi进行了比较，回顾一下前面传了那=哪些参数：edx、esi，edi。edi的值是rsp+0x8的值，也就等于用户输入的第一个值，那么这里其实就是将ecx与用户输入的值比较，如果ecx<=edi（用户输入），那么edx就等于均值-1，如果ecx>=edi，那么edx就等于均值+1。
然后回到开始循环，直到用户输入的值，也就是edi，等于均值。那其实这就是一个递归的过程。

这整个函数我们来总结一下就会发现，作用就是用来使用户输入的值等于均值的函数。

- 目前已知信息

分析到这里，那么我们现在看看已经得到了哪些信息：

1. 输入的值要小于0xe但大于等于0x0
2. 输入的值会被递归判断，最后要能够等于（edx+esi）/2
3. edx与esi的值已知分别为：0xe、0x0，均值为0x7

得到这些信息后，我们回到对`Phase_4`的分析，当func4函数结束后，程序回到了`Phase_4 <+65>`的位置

- 对`Phase_4 <+65>`到程序结束的分析

这里其实不用多说了，直接看这两句汇编：
```
cmp    DWORD PTR [rsp+0xc],0x0
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
```
这两句话就实现了一个功能，就是确定了我们输入的第二个数必须为0。

那么其实答案已经出来了，并且由于递归的存在，答案并不唯一

Phase_4的答案为：7 0

其他答案的区别仅在于输入后进行递归的次数不同而已

- **Phase_5分析**

输入命令`disassemble phase_5`即可得到第五关的汇编代码：

```
0x0000000000401062 <+0>:     push   rbx
   0x0000000000401063 <+1>:     sub    rsp,0x20
   0x0000000000401067 <+5>:     mov    rbx,rdi
   0x000000000040106a <+8>:     mov    rax,QWORD PTR fs:0x28
   0x0000000000401073 <+17>:    mov    QWORD PTR [rsp+0x18],rax
   0x0000000000401078 <+22>:    xor    eax,eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    eax,0x6
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzx  ecx,BYTE PTR [rbx+rax*1]
   0x000000000040108f <+45>:    mov    BYTE PTR [rsp],cl
   0x0000000000401092 <+48>:    mov    rdx,QWORD PTR [rsp]
   0x0000000000401096 <+52>:    and    edx,0xf
   0x0000000000401099 <+55>:    movzx  edx,BYTE PTR [rdx+0x4024b0]
   0x00000000004010a0 <+62>:    mov    BYTE PTR [rsp+rax*1+0x10],dl
   0x00000000004010a4 <+66>:    add    rax,0x1
   0x00000000004010a8 <+70>:    cmp    rax,0x6
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    mov    BYTE PTR [rsp+0x16],0x0
   0x00000000004010b3 <+81>:    mov    esi,0x40245e
   0x00000000004010b8 <+86>:    lea    rdi,[rsp+0x10]
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   eax,eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nop    DWORD PTR [rax+rax*1+0x0]
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    eax,0x0
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    rax,QWORD PTR [rsp+0x18]
   0x00000000004010de <+124>:   xor    rax,QWORD PTR fs:0x28
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    rsp,0x20
   0x00000000004010f2 <+144>:   pop    rbx
   0x00000000004010f3 <+145>:   ret
```

这里如果了解对于栈溢出的保护，可以看出这题开了Canary保护，我们从对eax的异或处开始分析

- 对`Phase_5 <+22>`的分析

我们来关注这五句话：

```
0x0000000000401078 <+22>:    xor    eax,eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    eax,0x6
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
```

第一步将eax异或，也就是将eax清零，然后用了一个函数来计算输入的长度，可以在下一步发现，输入的长度要为0x6，否则就会引爆炸弹。那么我们现在有了密码的第一个线索：**密码的长度为6**

当通过这一步检验后，会跳到+112的位置，这里将eax清零后，便跳到了+41的位置，其实经过我们后面的分析，会发现这里其实是一个循环，那现在我们来分析分析，+41的位置干了什么

- 对`Phase_5 <+41>`的分析

对汇编整体一看，就会发现，在后面，只要rax不等于0x6，就会回到+41的位置，可以看出，就是六次循环，那这个循环主要是做什么的呢？我们来看看下面几句话：

```
 0x0000000000401092 <+48>:    mov    rdx,QWORD PTR [rsp]
   0x0000000000401096 <+52>:    and    edx,0xf
   0x0000000000401099 <+55>:    movzx  edx,BYTE PTR [rdx+0x4024b0]
```
这里将我们输入的值赋给了rdx，然后将rdx与0xf与运算，也就是仅保留我们输入的后四位。而在+41的位置`0x000000000040108b <+41>:    movzx  ecx,BYTE PTR [rbx+rax*1]`这句话，将我们的输入转换为了ASCII码值，那么上面+52位置的作用就是将ASCII码的后四位保留在rdx中。

那么`Phase_5 <+55>`的位置是做什么的呢？这句话其实就是将我们得到的ASCII码的后四位作为对`0x4024b0`偏移，来得到新的字符串。因为我们前面分析了，现在的rdx里存放的是ASCII码的后四位，那么+55处的表达式就变为：**[ASCII码的后四位+0x4024b0]**。请记住这个表达式，非常重要。

当循环结束后，就会到`Phase_5 <+76>`的位置，那我们先来分析分析这里。

- 对`Phase_5 <+76>`的分析

```
0x00000000004010ae <+76>:    mov    BYTE PTR [rsp+0x16],0x0
   0x00000000004010b3 <+81>:    mov    esi,0x40245e
   0x00000000004010b8 <+86>:    lea    rdi,[rsp+0x10]
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
```

其实这里已经很明显了，他将我们前面得到的新字符串，与0x40245e处的字符串作了比较，很显然，0x40245e的字符串就是密码，那我们用命令`x/s 0x40245e`来看看这个位置有什么。

可以看见，这个位置存放着一个叫‘flyers’的字符串，那么这就是我们需要的密码。但是这里请注意，我们并不能直接输入这个密码，下面来讲讲为什么，以及怎么办。

- 对密码的分析

请看我们前面对于+41处的分析，我们会发现，我们输入的值并没有直接与正确答案比较，而是转换得到了一个新的字符串，也就是说，当我们输入了**flyers**后，程序得到的并不是这个字符串，而是转换后的字符串，这就会导致与密码不相等，炸弹爆炸。而前面分析了，我们的输入的ASCII码的后四位保留了下来，并作为偏移，生成了新字符串，前面的表达式还记得吗：**[ASCII码的后四位+0x4024b0]**，下面来讲讲怎么正确的输入

那为了得到正确的字符串，我们需要看看0x4024b0处到底存了什么，输入命令`x/s 0x4024b0`，可以发现，程序输出了一行字：`maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`，那么很显然，我们计算出偏移，就可以得到我们真正需要的字符串，可以发现‘f’处于这句话中的第9个位置（从0开始数），那么f的偏移为9，f的位置就为：**[9+0x4024b0]**，而由于只保留后四位作为偏移，那么我们输入的第一个只要后四位是9即可，这里我选择0x69，那么密码为flyers，我们只需要数一下出每个字母对应的偏移就可以得到我们需要输入的字母的ASCII码值，再转换成字母，即可得到所需要的输入（答案并不唯一），这里给出我的答案，我所选择的都是0x60加上偏移。

phase_5的答案：ionefg

- **Phase_6分析**

终于到最后一关了，这第六关属实老火，一堆又臭又长的代码（这就是传说中的老六吗），那我们接下来对代码逐步进行分析，使用命令`disassemble phase_6`，来得到如下的汇编代码：

```
 #这里到<+93>的位置做的任务是确保输入的六个数字都小于等于6
 0x00000000004010f4 <+0>:     push   r14
   0x00000000004010f6 <+2>:     push   r13
   0x00000000004010f8 <+4>:     push   r12
   0x00000000004010fa <+6>:     push   rbp
   0x00000000004010fb <+7>:     push   rbx
   0x00000000004010fc <+8>:     sub    rsp,0x50
   0x0000000000401100 <+12>:    mov    r13,rsp
   0x0000000000401103 <+15>:    mov    rsi,rsp
   0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers>
   0x000000000040110b <+23>:    mov    r14,rsp
   0x000000000040110e <+26>:    mov    r12d,0x0
   0x0000000000401114 <+32>:    mov    rbp,r13
   0x0000000000401117 <+35>:    mov    eax,DWORD PTR [r13+0x0]
   0x000000000040111b <+39>:    sub    eax,0x1
   0x000000000040111e <+42>:    cmp    eax,0x5
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
   0x0000000000401128 <+52>:    add    r12d,0x1
   0x000000000040112c <+56>:    cmp    r12d,0x6
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
   0x0000000000401132 <+62>:    mov    ebx,r12d
   0x0000000000401135 <+65>:    movsxd rax,ebx
   0x0000000000401138 <+68>:    mov    eax,DWORD PTR [rsp+rax*4]
   0x000000000040113b <+71>:    cmp    DWORD PTR [rbp+0x0],eax
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
   0x0000000000401145 <+81>:    add    ebx,0x1
   0x0000000000401148 <+84>:    cmp    ebx,0x5
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   0x000000000040114d <+89>:    add    r13,0x4
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
 #这里到<+121>的位置主要是对输入的数字，进行了运算：输入=7-输入
   0x0000000000401153 <+95>:    lea    rsi,[rsp+0x18]
   0x0000000000401158 <+100>:   mov    rax,r14
   0x000000000040115b <+103>:   mov    ecx,0x7
   0x0000000000401160 <+108>:   mov    edx,ecx
   0x0000000000401162 <+110>:   sub    edx,DWORD PTR [rax]
   0x0000000000401164 <+112>:   mov    DWORD PTR [rax],edx
   0x0000000000401166 <+114>:   add    rax,0x4
   0x000000000040116a <+118>:   cmp    rax,rsi
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   0x000000000040116f <+123>:   mov    esi,0x0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   0x0000000000401176 <+130>:   mov    rdx,QWORD PTR [rdx+0x8]
   0x000000000040117a <+134>:   add    eax,0x1
   0x000000000040117d <+137>:   cmp    eax,ecx
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:   mov    edx,0x6032d0
   0x0000000000401188 <+148>:   mov    QWORD PTR [rsp+rsi*2+0x20],rdx
   0x000000000040118d <+153>:   add    rsi,0x4
   0x0000000000401191 <+157>:   cmp    rsi,0x18
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:   mov    ecx,DWORD PTR [rsp+rsi*1]
   0x000000000040119a <+166>:   cmp    ecx,0x1
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:   mov    eax,0x1
   0x00000000004011a4 <+176>:   mov    edx,0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
   0x00000000004011ab <+183>:   mov    rbx,QWORD PTR [rsp+0x20]
   0x00000000004011b0 <+188>:   lea    rax,[rsp+0x28]
   0x00000000004011b5 <+193>:   lea    rsi,[rsp+0x50]
   0x00000000004011ba <+198>:   mov    rcx,rbx
   0x00000000004011bd <+201>:   mov    rdx,QWORD PTR [rax]
   0x00000000004011c0 <+204>:   mov    QWORD PTR [rcx+0x8],rdx
   0x00000000004011c4 <+208>:   add    rax,0x8
   0x00000000004011c8 <+212>:   cmp    rax,rsi
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    rcx,rdx
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   0x00000000004011d2 <+222>:   mov    QWORD PTR [rdx+0x8],0x0
   0x00000000004011da <+230>:   mov    ebp,0x5
   0x00000000004011df <+235>:   mov    rax,QWORD PTR [rbx+0x8]
   0x00000000004011e3 <+239>:   mov    eax,DWORD PTR [rax]
   0x00000000004011e5 <+241>:   cmp    DWORD PTR [rbx],eax
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    rbx,QWORD PTR [rbx+0x8]
   0x00000000004011f2 <+254>:   sub    ebp,0x1
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:   add    rsp,0x50
   0x00000000004011fb <+263>:   pop    rbx
   0x00000000004011fc <+264>:   pop    rbp
   0x00000000004011fd <+265>:   pop    r12
   0x00000000004011ff <+267>:   pop    r13
   0x0000000000401201 <+269>:   pop    r14
   0x0000000000401203 <+271>:   ret
```

从前面我对代码的注释，可以知道`phase_6 <+0>`到`phase_6 <+121>`的功能，这两部分，并不难理解，这里就不在赘述了。

而从121开始，后面的代码，我第一次看的时候完全不知所云，直到我发现了一个地址：`0x0000000000401183 <+143>:   mov    edx,0x6032d0`，在+143的地方有这样一个地址，抱着试一试的心态，我输入命令`x/x 0x6032d0`,查看了该地址里的值，发现是这样的一个值`0x6032d0 <node1>:       0x4c`，好家伙，看见前面的node1了吗，这时候我们心里其实可以大胆的猜测一下，从<+121>的位置往后，其实是构建了一个链表结构，node1表示第一个节点，那我们现在有了这个想法以后，再来看看这段代码：

```
mov    rax,QWORD PTR [rbx+0x8]
   0x00000000004011e3 <+239>:   mov    eax,DWORD PTR [rax]
   0x00000000004011e5 <+241>:   cmp    DWORD PTR [rbx],eax
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
```
这一段话里，我们可以看见，如果rbx的值小于了eax的值，则会引爆炸弹，那我们看看rbx和eax代表着什么，可以往这几句话之前看，可以看见，分别是当前节点的值，和下一节点的值，那么其实这里就是要求了当前节点的值要大于下一节点的值，那么可以知道链表是根据节点值，从大到小排列，那我们来看看链表的值，输入命令`x/24w 0x6032d0`,可以看见，输出了六个节点，而根据我对代码的注释，可以发现，只能输入六个值，也就是说，链表只能有六个节点。

```
0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000
```

那么我们根据六个节点的值，来对其排序，可以得到，最后的顺序为：node3>node4>node5>node6>node1>node2，那么密码就是：3 4 5 6 1 2，但是，同样的，由于前面的代码对我们输入的数字进行了运算：输入=7-输入，所以我们在输入的时候要先用7减去密码。

phase_6的答案为：4 3 2 1 6 5